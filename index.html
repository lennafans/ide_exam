<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>
    <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/glacial-indifference"
     type="text/css"/>
  </head>
  <body>
<h1>Music cloud</h1>
<p>nbs151 (Dan Graakjær)   and   xtp778 (Jens Egholm)</p>
<svg id="svg"></svg>
<style>
h1 {
    font-size:350%;
}
body {
font-family: 'GlacialIndifferenceRegular';
margin-left:30vw;
width: 60vw;
}
#svg {
margin-left: -20vw;
}
.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}
.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}
</style>
<script type="text/javascript">
d3.select(window).on('load', () => {
  const width = window.innerWidth * 0.8;
  const height = window.innerHeight * 0.8;
  const padding = 50;

  const svg = d3.select("#svg")
    .attr("width", width)
    .attr("height", height)

  var svg_node = svg.append("g")
    .attr("class", "nodes")
    .selectAll(".node")
  var svg_link = svg.append("g")
    .attr("class", "links")
    .selectAll(".link")

  const simulation = d3.forceSimulation()
    .force("link", d3.forceLink()
      .id(function(d) { return d.id; })
      .distance(d => d.distance * 1.3)
      .iterations(10))
    .force("charge", d3.forceManyBody()
      .strength(-100)
      .distanceMin(30))
    .force("collission", d3.forceCollide(20))
    .force("center", d3.forceCenter(width / 2, height / 2));

  d3.json("output.json", (error, songs) => {
    if (error) throw error;
    //const scalex = d3.scaleLinear().domain([d3.min(tags, d => d.x), d3.max(tags, d => d.x)]).range([padding, width - padding]) // scale x
    //const scaley = d3.scaleLinear().domain([d3.min(tags, d => d.y), d3.max(tags, d => d.y)]).range([padding, height - padding]) // scale y

    const nodeSet = new Set();
    const nodes = [songs[0]];
    const links = [];
    function expandNode(node) {
      if (!node.hasOwnProperty('visited')) {
        const link = links[node.index]
        const parent = link ? (link.source.id == node.id ? link.target : link.source) : null;

        node.similars.map(t => {
            const target = songs[t[1]]
            // Insert the song as a node (if it doesn't already exist) and
            // return all the links
            if (!nodeSet.has(target.id) && target.id != node.id) {
              nodeSet.add(target.id)

              if (parent) {
                target.x = node.x + (node.x - parent.x) * 0.5 + Math.random() * 5;
                target.y = node.y + (node.y - parent.y) * 0.5 + Math.random() * 5;
              } else {
                target.x = (Math.random() - 0.5) * 40
                target.y = (Math.random() - 0.5) * 40
              }
              nodes.push(target)
              links.push({distance: t[0], source: node, "target": target})
            }
          });
        node['visited'] = true;
        drawGraph()
      }
    }

    function ticked() {
      svg_link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      svg_node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
    }

    function drawGraph() {

      // Restart simulation
      var shouldRender = true;
      simulation.nodes(nodes).on("tick", ticked);
      simulation.force("link").links(links);
      simulation.alpha(1).alphaTarget(0).restart()

      // Create links
      svg_link = svg_link.data(links);
      const svg_link_elements = svg_link.enter()
        .append("line")
        .attr("class", "link")
        .attr("stroke-width", 2)
      svg_link = svg_link_elements.merge(svg_link)

      // Create nodes
      svg_node = svg_node.data(nodes);
      const svg_node_elements = svg_node.enter().append("circle")
        .attr('class', 'node')
        .attr("r", 5)
        .attr("fill", "black") //function(d) { return color(d.group); })
        .on("click", d => {
          expandNode(d)
          drawGraph()
        })
      svg_node_elements.append("title").text(d => d.id);
      svg_node = svg_node_elements.merge(svg_node)

    };

    expandNode(nodes[0])
  });
});
</script>
</body>
</html>
