<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>
    <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/glacial-indifference"
     type="text/css"/>
  </head>
  <body>
<h1>Music cloud</h1>
<p>nbs151 (Dan Graakjær)   and   xtp778 (Jens Egholm)</p>
<svg id="svg"></svg>
<style>
h1 {
    font-size:350%;
}
body {
font-family: 'GlacialIndifferenceRegular';
margin-left:30vw;
width: 60vw;
}
#svg {
margin-left: -20vw;
}
.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}
.node circle {
  stroke: #fff;
  stroke-width: 1.5px;
}
.node.expanded circle {
  fill: #DD9611;
}
.node.closed circle {
  fill: #622;
  stroke: #ccc;
  stroke-width: 6px;
}
.node.closed:hover {
  cursor: pointer;
}
.node.closed:hover text {
  display: block;
}
.node.closed text {
  color: rgba(0, 0, 0, 0.1);
  font-size: 0.7rem;
  display: none;
}
</style>
<script type="text/javascript">
d3.select(window).on('load', () => {
  const width = window.innerWidth * 0.8;
  const height = window.innerHeight * 0.8;
  const padding = 50;

  const svg = d3.select("#svg")
    .attr("width", width)
    .attr("height", height)
    .call(d3.zoom().on("zoom", () => {
      svg.attr("transform", () => {
        return d3.event.transform
      })
    }))
    .append("g")

  var svg_link = svg.append("g")
    .attr("class", "links")
    .selectAll(".link")
  var svg_node = svg.append("g")
    .attr("class", "nodes")
    .selectAll(".node")

  const simulation = d3.forceSimulation()
    .force("link", d3.forceLink()
      .id(function(d) { return d.id; })
      .distance(d => d.distance * 1.5)
      .iterations(1))
    .force("charge", d3.forceManyBody()
      .strength(-100)
      .distanceMin(30))
    .force("collission", d3.forceCollide(30))
    .force("center", d3.forceCenter(width / 2, height / 2));

  d3.json("output.json", (error, songs) => {
    if (error) throw error;
    //const scalex = d3.scaleLinear().domain([d3.min(tags, d => d.x), d3.max(tags, d => d.x)]).range([padding, width - padding]) // scale x
    //const scaley = d3.scaleLinear().domain([d3.min(tags, d => d.y), d3.max(tags, d => d.y)]).range([padding, height - padding]) // scale y

    const nodeSet = new Set();
    const nodes = [songs[0]];
    const links = [];
    function expandNode(node) {
      if (!node.hasOwnProperty('visited')) {
        const link = links[node.index]
        const parent = link ? (link.source.id == node.id ? link.target : link.source) : null;

        node.similars.map(t => {
            const target = songs[t[1]]
            // Insert the song as a node (if it doesn't already exist) and
            // return all the links
            if (!nodeSet.has(target.id) && target.id != node.id) {
              nodeSet.add(target.id)

              if (parent) {
                target.x = node.x + (node.x - parent.x) * 0.5 + Math.random() * 5;
                target.y = node.y + (node.y - parent.y) * 0.5 + Math.random() * 5;
              } else {
                target.x = (Math.random() - 0.5) * 40
                target.y = (Math.random() - 0.5) * 40
              }
              nodes.push(target)
            }
            links.push({distance: t[0], source: node, "target": target})
          });
        node['visited'] = true;
        drawGraph()
      }
    }

    function ticked() {
      svg_link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      svg_node
          .attr("transform", d => "translate("+d.x+","+d.y+")")
    }

    function drawGraph() {

      // Restart simulation
      var shouldRender = true;
      simulation.nodes(nodes).on("tick", ticked);
      simulation.force("link").links(links);
      simulation.alpha(1).restart()

      // Create links
      svg_link = svg_link.data(links);
      const svg_link_elements = svg_link.enter()
        .append("line")
        .attr("class", "link")
        .attr("stroke-width", 2)
      svg_link = svg_link_elements.merge(svg_link)

      // Create nodes
      svg_node = svg_node.data(nodes);
      const svg_node_elements = svg_node.enter()
        .append("g")
        .attr("class", "node")
        .on("click", d => {
          expandNode(d)
          drawGraph()
        })
      svg_node_elements.append("circle")
        .attr("fill", "black") //function(d) { return color(d.group); })
      svg_node_elements.append("text")
        .text(d => d.id)
        .attr("x", d => - 7 - d.id.length * 3)
        .attr("y", -20)
      svg_node = svg_node_elements.merge(svg_node)

      // Update nodes
      svg.selectAll(".node")
        .attr("class", d => "node " + (d.visited ? "expanded" : "closed"))
      svg.selectAll("circle")
        .attr("r", d => d.visited ? 17 : 12)
    };

    expandNode(nodes[0])
  });
});


function srch() {
  var input = document.getElementById("userInput").value;
  const dbase = songs.map((song,index)=> [song.id,index])
  const tmp = dbase.filter(song=> song[0].toLowerCase().includes(input.toLowerCase()))
  const results = tmp.map(song => songs[song[1]])
  alert(results);
}



</script>
</body>
</html>
